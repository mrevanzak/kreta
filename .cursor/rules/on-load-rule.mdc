# Swift Project Development Guidelines

This guide outlines the critical development principles for this Swift project.

<rule>
name: on_load_rule
filters:
  - type: event
    pattern: "cursor_start"
  - type: command
    pattern: "@principles"

actions:

- type: suggest
  message: |

  # Critical Development Principles

  This Swift project follows strict architectural and code quality guidelines:

  ## 1. Architecture

  We follow **MVVM-inspired architecture** with:

  - **Stores**: `@Observable` classes managing state (TrainMapStore, ProductStore, etc.)
  - **Services**: Business logic and integrations (JourneyService, TrainLiveActivityService, etc.)
  - **View Models**: Feature-specific UI logic when needed (AddTrainViewModel)
  - **Views/Screens**: SwiftUI presentation layer
  - **Models**: Codable DTOs and domain types

  **Key principle**: Store manages state, services handle business logic, views present UI. Stores and services are testable and framework-agnostic where possible.

  ## 2. SwiftUI Best Practices

  All UI follows SwiftUI patterns:

  - Use `@Observable` stores for state management
  - Prefer value types (`struct`) for models
  - Use `@MainActor` for UI-affecting operations
  - Avoid view-specific business logic; move to stores or services
  - Use environment for dependency injection (ConvexClient, Telemetry)

  ## 3. Code Quality Principles

  Follow Swift best practices:

  1. Prefer readability over strict rules
  2. Use appropriate naming (Apple API Design Guidelines)
  3. Keep types focused on single responsibility
  4. Prefer composition over inheritance
  5. Use protocol extensions for shared behavior
  6. Don't abbreviate names
  7. Keep files focused and well-organized
  8. Use `let` over `var` when possible
  9. Leverage Swift's type system for safety

  ## 4. Testing Principles

  Write tests for critical business logic and stores:

  Test coverage goals:

  - Stores: Core state management logic
  - Services: Business operations
  - Critical user flows

  Always follow AAA pattern (Arrange-Act-Assert).

  ## 5. Package Structure

  Code organized by role:

  ```
  Sources/
  ├── Stores/          # State management (@Observable)
  ├── Services/        # Business logic
  ├── Screens/         # Full-screen views
  ├── Views/           # Components and feature views
  ├── Models/          # DTOs and domain types
  ├── Controllers/     # High-level orchestration
  ├── Networking/      # HTTP abstractions
  ├── Navigation/      # Routing and deep linking
  ├── Utility/         # Helpers and constants
  └── Extensions/      # Type extensions
  ```

  ## 6. Naming Conventions

  - Stores: Role + "Store" (TrainMapStore, ProductStore)
  - Services: Role + "Service" (JourneyService, TrainLiveActivityService)
  - Views: Description + "View" (TrainMapView, AddTrainView)
  - Models: Business terms (Train, Station, Route, Journey)
  - Extensions: Extended type + feature (EnvironmentValues+Extensions)

  ## 7. Error Handling

  - Store methods throw errors instead of maintaining error state
  - Use typed errors (enum NetworkError, TrainMapError)
  - Handle errors at call sites with do/try/catch
  - Use `showMessage` environment action for user feedback

  ## 8. Dependency Injection

  - Use `Dependencies.shared` for singletons (ConvexClient, Telemetry)
  - Inject via init or environment for testability
  - Services accept dependencies through init

  ## 9. Documentation Requirements

  - Public APIs: Documentation comments
  - Complex logic: Inline comments
  - Store methods: Describe purpose and errors
  - Tests: Clear arrange-act-assert sections

  ## 10. Code Review Checklist

  - Follows MVVM architecture
  - Observes Swift best practices
  - Has test coverage for critical paths
  - Properly documented
  - Error handling in place
  - Uses telemetry for observability

examples:

- input: |
  I need to implement a feature to track train delays
  output: |
  I'll help you implement train delay tracking following our project principles:
  Let's approach this using MVVM architecture and Swift best practices:

  1. First, I'll create models in Models/:

     - `TrainDelay` struct conforming to Codable and Identifiable
     - `DelayInfo` for delay details

  2. Next, I'll add a service in Services/:

     - `TrainDelayService` with async methods to fetch delay information
     - Uses ConvexClient for real-time delay updates

  3. Then I'll update the store in Stores/:

     - Add delay tracking to `TrainMapStore`
     - Handle delay state with proper error throwing

  4. Finally, I'll update views in Views/:
     - Display delays on TrainServiceRow
     - Show delay indicators in UI
       I'll follow Swift naming conventions, use async/await for concurrency, and ensure proper error handling throughout.

metadata:
priority: critical
version: 1.0
</rule>
